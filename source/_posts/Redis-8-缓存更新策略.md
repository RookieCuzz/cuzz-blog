---
title: Redis-8.缓存更新策略
date: 2025-09-03 12:47:25
tags:
---
# 缓存更新策略

## 1. 缓存空间满后的淘汰策略（Eviction Policies）
Redis 支持多种淘汰策略:
- allkeys-lru：对所有键都采用 LRU（最近最少使用）淘汰
- volatile-lru：仅对设置了过期时间的键采用 LRU 淘汰
- allkeys-lfu / volatile-lfu：采用 LFU（最不常使用）策略，分别针对所有键或仅针对有过期键
- volatile-ttl：优先淘汰剩余 TTL 值最短的键
- allkeys-random / volatile-random：随机淘汰所有键或仅过期键


**删除机制**
Redis 并不一次扫描所有键，而是使用随机采样方式（通过 maxmemory-samples 参数控制）来挑选候选项，再依据算法选择淘汰目标
此外，如果删除的是大对象，Redis 会使用“延迟释放”（lazyfree）机制，将内存回收交给后台线程，从而减少阻塞

## 2. 超时剔除（TTL 机制）
- 定期删除（Scheduled Deletion）：后台线程每隔一段时间（默认每 100ms）随机检查一部分设了过期时间的键，并删除已过期的键，如果删除比例高它会继续扫描 
- 惰性删除（Lazy Deletion）：当访问某个键时才检查其是否过期，如果过期则删除处理；未过期则照常返回

## 3. 主动更新（主动失效机制）
- Cache-Aside （旁路加载/延迟加载）模式: 应用侧控制缓存生命周期：先更新数据库，再显式删除缓存，这样下一次访问时会触发重新加载缓存，保持一致性
- Write-Through（写穿）模式: 写操作时同时更新缓存和数据库，确保缓存总是为最新状态，但可能增加写入延迟
- 事件驱动刷新: 当数据库变更时，主动向缓存层下发消息（通过消息系统、事件总线/Redis广播等方式），使缓存同步更新或删除，这是对一致性要求极高场景的常用做法