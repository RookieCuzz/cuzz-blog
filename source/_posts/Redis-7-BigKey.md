---
title: Redis-7.BigKey
date: 2025-09-03 11:26:17
tags:
---

#  Big Key
## 什么是 Big Key？
- 字符串类型（String）：、
value 很大时属于 Big Key。按通用理解：
超过 1MB 即可视为 Big Key；也有人在高并发场景下将 10KB判断为 Big Key。
- 非字符串类型（List、Hash、Set、ZSet）：
元素数量或组合内存过大即为 Big Key。
例如 超过 10,000 个元素 或总内存超限。
华为云标准：单 Key 超过 10 KB 或总元素内存 > 50 MB，或元素数量 > 5000     




## Big Key如何影响我们的系统?
<img src="https://github.com/RookieCuzz/cuzz-blog/blob/main/source/_posts/images/20.png?raw=true" alt="图" width="1200" />

**Always 模式：**  
每次写操作都会同步调用 fsync()，如果写入的是 big key（如几 MB 级别），会直接阻塞 Redis 主线程，影响所有请求的响应时延。   
**EverySec 模式：**   
写入操作结束后，主线程不会立即调用 fsync()，而是由后台定时器异步执行，从而极大缓解主线程阻塞问题。   
**No 模式：**     
完全依赖操作系统决定何时写入磁盘，不会阻塞主线程，但数据持久化可靠性较低。   

**Redis 在执行写操作（如 SET key value）时，其执行顺序是：**   
1.写入内存状态（数据立即对客户端可见.    
2.将命令追加到 AOF 日志里.    
3.根据 appendfsync 策略决定是否立即刷新到磁盘.   

| 模式                           |                       描述                       | 数据丢失风险         |
|--------------------------------|:------------------------------------------------:|----------------------|
| `appendfsync always`           | 每次写入后立即执行 `fsync`，确保数据同步到磁盘。性能最差，但安全性最高。 | 最小损失（几乎无丢失） |
| `appendfsync everysec` （默认）|     写命令追加到内存缓冲区，每秒执行一次 `fsync`，性能较好，折中选择。     | 可能丢失最近 1 秒的数据|
| `appendfsync no`               |    仅写入内存缓冲区，由操作系统决定何时将数据落盘。性能最佳，最不安全。    | 丢失时间不定，取决于操作系统行为，风险最大 |
## Big Key 带来的主要影响
性能下降：操作大 Key（读写、删除）会加重 CPU 和调用延迟。    
内存消耗高：容易触发 eviction 或 OOM，影响全局缓存策略。    
网络带宽压力：频繁访问大 Key 会产生大量数据传输，堵塞网络。    
主从同步延迟：大 Key 同步耗时长，可能影响复制延迟或造成 switchover。    
数据倾斜（集群模式）：某节点负载过重而导致集群资源不均匀。    
操作阻塞：如执行 DEL 删除大 Key 会阻塞主线程，可能导致服务响应失败。    